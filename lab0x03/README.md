# Lab 0x03 - Fuzz Testing

Submission deadline: 04.05.2023 - 22:59:59 CET

## What is it?

Fuzz testing (AKA fuzzing) is a software testing technique where a program-under-test is executed
with automatically-generated inputs. The goal of fuzzing is to find bugs in the system by feeding it
unexpected inputs. A fuzzer's key aspects are concrete execution and _speed_. For this lab, you will most likely need an Ubuntu 22.04 VM for best compatibility.

<details>
  <summary>
    Reference
  </summary>
  <img src="https://i.imgur.com/E1YRsXQ.jpg"></img>
</details>

## Phase 1 (AFL++)

Your task in this phase of lab 0x03 is to set up AFL++ and to use it to find bugs in our PNG parsing
library.

### AFL++ (American Fuzzy Lop++)

While it is possible to test programs with completely random inputs, it can be inefficient. Many of
the test cases will cause the input to fail sanity checks, and exit before reaching important code
segments. Fuzzers will, therefore, use various metrics and feedback to create more semi-valid
inputs.

AFL++ uses simple machine learning for input generation (genetic algorithms). Successful inputs (those
that lead to new or interesting behaviour) are kept and combined to produce more (hopefully)
successful inputs. AFL++ can also mutate them (e.g. flip some bits), or generate random input (havoc
mode) to add fresh genes to the population. Usually valid input files are provided as seeds
(starting files) to the fuzzer.

AFL++'s measure of success for an input is new code coverage. A bug cannot be discovered by a fuzzer
unless it executes the code where that bug resides. By exploring previously unexecuted code, the
fuzzer has a higher chance of encountering previously unseen bugs.

AFL++ uses crashes as indicators for bugs. If the program crashes, AFL++ knows that it has encountered a
bug. However, one bug can cause crashes for many different inputs. AFL++ attempts to *deduplicate*
crashes based on code coverage; if a crashing input exercises unseen code, it is considered unique.
This deduplication is imprecise, and the number of reported unique crashes is usually inflated,
generally resulting in an over-approximation of discovered bugs.

### Files

- `afl++`
  - `crc.h`
  - `crc.c`
  - `example_crash`
  - `pngparser.h`
  - `pngparser.c`
  - `size.c`
  - `Makefile`
- `seeds`
  - `rgba.png`
  - `palette.png`

The source code for this lab consists of a library we will be fuzzing (`crc.h`, `crc.c`,
`pngparser.h`, `pngparser.c`) and a test harness (`size.c`). The test harness is just a small
program that executes the code that we want to test. The directory contains a Makefile and an example input that will cause a crash (`example_crash`, due to the uninitialized `current_chunk->chunk_data`) as well.

The `size` program takes an image file name as input and outputs the dimensions of the image: `size test_image.png`.

### Setting up AFL++

1. Download AFL++ from https://github.com/AFLplusplus/AFLplusplus
  1. `git clone https://github.com/AFLplusplus/AFLplusplus.git`
  1. `cd AFLplusplus`
  1. `git submodule update --init`
1. Refer to the [Building and installing afl++](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md) section for building pre-requisites
1. Build and install AFL++
  1. `make source-only NO_NYX=1`
  1. `sudo make install`
1. Go to the `afl++` directory provided with the lab 0x03 source code
1. Code changes are sometimes needed when fuzzing
  1. Find the function `is_png_chunk_valid` in pngparser.c
  1. Edit it so it always returns 1
1. Edit the Makefile so the compiler used is `afl-clang` and `-fsanitize=address` is on
1. Run make
1. Create two directories in `afl++`: `afl_in` and `afl_out`
1. Copy the two image files from `seeds` to `afl_in`
1. Run `afl-fuzz -i afl_in -o afl_out -- <path_to_size> @@`
1. Follow the instructions on screen to run AFL++. You may need to change some system settings (disable crash reporting
   and change the CPU governor)
   * `sudo bash -c 'echo core >/proc/sys/kernel/core_pattern'`
1. Let AFL++ run until you are satisfied with the number of unique crashes

### The Task

1. You are required to find and fix 4 bugs in `pngparser.c`
2. For each bug provide a PoC (the crashed input generated by AFL++)
3. Submit your answers to the following questions in the file `ANSWERS.md`:
  1. Why did you need to change `is_png_chunk_valid`?
  2. Why did you have to use `afl-clang` to compile the source (and not e.g. ordinary clang)?
  3. How long did you fuzz? How many crashes in total did AFL++ produce? How many unique crashes?
  4. Why are hangs counted as bugs in AFL++? Which type of attack can they be used for?
  5. Which interface of `libpngparser` remains untested by AFL++ (take a look at `pngparser.h`)?

You are free to fix and report as many bugs as you like. Extra bugs will be used as replacements for the ones which
aren't accepted.

*Do not apply "point fixes" (which only stop the PoC from crashing but don't fix the underlying fault), we have some measures to detect it. Fix the bugs
properly*. For example, if you have a crash because of the memory corruption (e.g. double free), don't just add if/else to exit
early. Prevent the memory corruption. If you have an out-of-bounds read/write, you will need to do a proper bounds
checking, not just to eliminate the bug for that one input file. Reading the specification may help, especially
with the chunk handling. Instead of crashing, the library function should return an error code. If you need to modify
some function prototypes to return that code, and pass it to a call function, do so. Otherwise, handle the error, return
`NULL`, `-1`, or set an error flag, and make sure this is handled properly in the calling function.

Try to fix the code in such a way that it doesn't crash with the provided PoC anymore. Breaking the
functionality for valid files is unacceptable.

Remember that you need to recompile the binaries with normal GCC/Clang and a `-g` flag to debug them. Pass the AFL++ crashing
input as an argument and debug the program in GDB.

## Phase 2 (libFuzzer)

In the previous phase, we have seen AFL++ - a coverage guided fuzzer especially suited to fuzzing file parsers. However,
AFL++ isn't designed to fuzz other types of interfaces. In this phase of the lab we will study libFuzzer which can fuzz
arbitrary APIs.

Your task in this phase of lab 0x03 is to set up libFuzzer, customize its mutator, and use it to find bugs in our PNG parsing library.

### libFuzzer

libFuzzer comes built-in with the `clang` compiler. It is a coverage-guided mutational fuzzer. Mutational fuzzers
randomly mutate existing input to generate new inputs. Coverage-guided fuzzers use newly discovered code paths to
determine which inputs are better.

Sanitization is a process of instrumenting memory allocation and accesses to prevent memory bugs. While AFL++ can work
with a sanitizer, it can lead to false memory exhaustion bugs - sanitizers allocate a lot of memory. libFuzzer natively
supports sanitizers, and their usage is recommended.

Unlike AFL++, libFuzzer requires some setup. The user needs to write fuzzing stubs for every interface they want to test.
These stubs take random input from the fuzzer and use it to call the interface being tested. This makes libFuzzer more
versitile than AFL++ - it can test all functions, not only the ones that parse files.

However, there are dependencies among functions, that is, some functions are supposed to accept the processing results 
of other functions as arguments (e.g., `store_png` and `load_png` in our target library). If we ignore such dependencies 
and just feed randomly mutated data to those arguments when testing, the caught bug can be a false positive when the 
argument is impossible to be generated by the dependent function. 

To avoid such kind of false positives, we can include the tested function's dependent functions in the fuzzing stub as 
well, to make sure that every bug is triggered without violating the API usage. For example, in our target library, to 
fuzz the `img` argument of `store_png`, it makes more sense to let libFuzzer mutate the input files, use `load_png` to 
parse them and generate the `img` arguments, then pass the `img` to `store_png`.

Making the dependent function successfully complete the required processing is a prerequisite for the testing. 
Otherwise, if the dependent function aborts early and fails to generate the required argument, the tested function has 
no chance to run. So to make sure `load_png` successfully generates the `img` required by `store_png`, we need the mutator 
to mutate according to the YOLO PNG format, to get inputs that can pass all the format checks in `load_png` and generate the `img`.

Luckily, libFuzzer provides some APIs to support customizing the default mutator as we wish, with which we can get 
well-formatted input files. To make our life easier, libFuzzer also provides an example custom mutator 
([png_mutator.h](https://github.com/google/fuzzer-test-suite/blob/master/libpng-1.2.56/png_mutator.h)) for the PNG format, 
but is not perfectly adapted to our YOLO PNG format.

### Files

- `libfuzzer`
  - `crc.h`
  - `crc.c`
  - `example_crash`
  - `png_mutator.h`
  - `pngparser.h`
  - `pngparser.c`
  - `fuzzer_load_png.cc`
  - `Makefile`
- `seeds`
  - `rgba.png`
  - `palette.png`

The source code for this lab consists of a library we will be fuzzing (`crc.h`, `crc.c`, `pngparser.h`, `pngparser.c`), the example custom mutator for PNG format (`png_mutator.h`),
and a fuzzing stub (`fuzzer_load_png.cc`). The directory also consists of a Makefile with some of the targets not implemented and an example input that will cause a crash (`example_crash`, due to the uninitialized `current_chunk->chunk_data`).

### Setting up libFuzzer

1. If it's not already, install `clang` on your machine (`sudo apt install clang` on Ubuntu/Debian/Mint)

1. Open `Makefile`
   1. `CFLAGS` stores the compilation flags.
      1. `-g` compiles debug version of the binaries.
      1. `-fsanitize=fuzzer,address` compiles the binaries with the instrumentation (`fuzzer`) and ASan (`address`). Some valid values are:
         1. `-fsanitize=fuzzer` - compile without any sanitization
         1. `-fsanitize=fuzzer,address` - compile with ASan (Address Sanitizer) (We will use this for the lab)
         1. `-fsanitize=fuzzer,undefined` - compile with UBSan (Undefined Behavior Sanitizer)
         1. `-fsanitize=fuzzer,signed-integer-overflow` - compile with a part of UBSan
         1. `-fsanitize=fuzzer,memory` - compile with MSan (Memory Sanitizer)

   1. For every interface that we want to fuzz, we will write a separate libFuzzer stub - a separate fuzzing program.
      1. `fuzzer_load_png` is the fuzzing stub which loads an arbitrary image.
      1. Notice the `TODO` lines. Your job will be to implement the missing stubs.

   1. If you would like to try the example PNG mutator, append `-DPNG_MUTATOR_DEFINE_LIBFUZZER_CUSTOM_MUTATOR` to the compilation command of the fuzzing stub to enable it.
  
   1. Enable the `check` line and test it with `make check` after finishing the TODOs to check if you fix the example bug correctly and your code compiles successfully. 

1. Apply the fixes of the bugs you found with AFL++ to `pngparser.c`, as we would like to find some new bugs with libFuzzer.

1. Open `fuzzer_load_png.cc`
   1. Every libFuzzer stub contains `int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)`.
      It is the function that the fuzzer calls with the random data. `data` contains the mutated
      data, while `size` denotes its length.
   1. Our interface (`load_png`) expects a file, so we write our data into the file and pass it to the function.
      * N.B. If we run multiple instances of the fuzzer the filename will be the same.
   1. If the fuzzer passes less data than required by the interface, the stub can just return 0.
   1. If the function takes multiple parameters, we can provide default values as other inputs.
   1. If we want to fuzz multiple parameters at the same time, we can manually split `data` among them.
      (e.g. first 4 bytes denote an integer parameter, and the remaining N-4 bytes are the image buffer).

2. Run `make`

3. Run `./fuzzer_load_png <seed-directory>` and wait for a crash. The seed directory is `./seeds`, do not forget it.

4. Fix the bug
   1. In some cases you can know the bug cause directly from the `asan` report, otherwise:
   2. Run `gdb ./fuzzer_load_png`
   3. In GDB run: `run example_crash`
   4. Debugging in progress...
   5. `current_chunk->chunk_data` is never initialized to NULL, leading to it being freed in the error handling code.
   6. Initialize `current_chunk->chunk_data` to NULL.
   7. Execute `./fuzzer_load_png example_crash` to verify that the bug has been fixed.

5.  Continue fuzzing :)

### The Task

1. You are required to implement fuzzers missing from the Makefile:
   1. `fuzzer_load_png_name`
   1. `fuzzer_store_png_rgba`
   1. `fuzzer_store_png_palette`

   Note that for fuzzing the arguments of `store_png`, you are supposed to let libFuzzer mutate the content input files, use `load_png` to parse them and generate the `img` arguments, then pass the `img` to `store_png`.

1. Customize the example PNG mutator (`png_mutator.h`) to adapt the YOLO PNG format in `yolo_png_mutator.h`, with the goal of passing all the format checks and successfully generate an `img`. Append `-DYOLOPNG_MUTATOR_DEFINE_LIBFUZZER_CUSTOM_MUTATOR` to the compilation command in `Makefile` to enable it in the fuzzing stub:
   1. `fuzzer_load_png_custom_mutator`
   1. `fuzzer_store_png_rgba_custom_mutator`
   1. `fuzzer_store_png_palette_custom_mutator`

1. Find, report, and fix 6 bugs in the Y0L0 PNG parsing library (the above example of uninitialized `current_chunk->chunk_data` does not count). For each bug found, copy the libFuzzer output to a `crash.log` file and include it in your submission. For this phase, we will consider ANYTHING that triggers a crash with ASan a bug: crashes, leaks, invalid frees, invalid accesses... You are free to use any of the mutators (the default one, the example PNG mutator, and your custom YOLO PNG mutator), and fix and report as many bugs as you like. Extra bugs will be used as replacements for the ones which aren't accepted.

1. Submit your answers to the following questions in the file `ANSWERS.md`:
  1. You did not change `is_png_chunk_valid` in this lab, does it affect the performance of libFuzzer's default mutator? What about the example PNG mutator and your custom YOLO PNG mutator?
  2. How many PCs are covered within `100000 fuzzing runs` with your `fuzzer_store_png_rgba`, equiped with libFuzzer's default mutator, the example PNG mutator, and your custom YOLO PNG mutator separately? Do these numbers reflect the extent to which `store_png` has been teseted?
  3. Do you think the mutator you customized (that aims at only generating well-formatted YOLO PNG inputs) helpful for finding bugs in `load_png`? Why?

Running `make all` should build all fuzzers with the names identical to their source files (minus the extension).

Useful libFuzzer flags:

- `-workers=N` sets the maximum number of concurrently executing processes
- `-print_pcs=1` prints out newly covered PCs.
- `-runs=N` sets the total number of fuzzing runs.
- `-jobs=N` set the total number of fuzzing jobs. Runs are distributed among jobs. Maximally `workers` jobs can be active at a time.


## Grading
This lab is graded over 40 points: 
- 20 points of the 10 reported bugs
- 5 points for answering the questions
- 15 points for the custom mutator

Refer to the "Submission Format" section of this handout for instructions on tasks and deliverables. 
Note that you will get 0 point if the submitted code does not compile. So make sure your code pass the `make check` successfully.

### Grading for Bugs
Possible bug categories are as follows:

- Double free
- Bad free
- Use after free
- Stack out-of-bound read
- Stack out-of-bound write
- Heap out-of-bound read
- Heap out-of-bound write
- Uninitialized variable
- NULL pointer deference
- Memory exhausted
- Memory leak

We will compile your fixed library code and count for valid bug fixes, so make sure your fixes are solid. 
We consider a bug fixed if we can't reproduce it with our known crashing inputs (like we did in `make check` for the example bug). Each valid fix worths 2 points. Code with compile errors or with "point fixes" gets 0 point.

### Grading for Custom Mutator
We marked 5 checkpoints in the library source code with `/* For grading the custom mutator */`. We will compile your mutator, run it with our `fuzzer_load_png_custom_mutator` fuzzing stub for 10000 iterations, and count the success and error times at each checkpoint. Among the first four checkpoints, you get 3 points for a checkpoint if it observes no error times but non-zero success times (the given seeds do not count). For the fifth checkpoint, you get 3 points if it observes zero error times. 
Make sure you pass a checkpoint by generating the inputs that conform to the formatting rule, instead of by not generating certain types of chunks. We will check it, 0 point if it happens.

## Submission format

The file structure is as follows. 
Please submit a zip file <sciper>.zip on Moodle within the deadline (generate it by running `zip -r <sciper>.zip afl++ libfuzzer`), an example valid <sciper> is 123456.

- `afl++`
  - `src` - put your source code to this directory
    - `crc.h`
    - `crc.c`
    - `example_crash`
    - `pngparser.h`
    - `pngparser.c` - with your fixes for the bugs found with AFL++ and `is_png_chunk_valid` patched to return 1
    - `size.c`
    - `Makefile` - with `make check` enabled and `-fsanitize=address` in the `CFLAGS`
  - `reports`
    - `ANSWERS.md`
    - `00`
      - `poc.bin`
    - `01`
      - `poc.bin`
    - `02`
      - `poc.bin`
    - `03`
      - `poc.bin`
- `libfuzzer`
  - `src` - put your source code to this directory
    - `crc.h`
    - `crc.c`
    - `example_crash`
    - `pngparser.h`
    - `pngparser.c` - with your fixes of the bugs you found with both AFL++ and libFuzzer.
    - `fuzzer_load_png.cc`
    - `fuzzer_load_png_name.cc`
    - `fuzzer_store_png_rgba.cc`
    - `fuzzer_store_png_palette.cc`
    - `Makefile` - with `make check` enabled and `-fsanitize=fuzzer,address` in the `CFLAGS`
    - `yolo_png_mutator.h` - your customized mutator for the YOLO PNG format.
  - `reports`
    - `ANSWERS.md`
    - `00`
      - `poc.bin`
      - `crash.log`
    - `01`
      - `poc.bin`
      - `crash.log`
    - `02`
      - `poc.bin`
      - `crash.log`
    - `03`
      - `poc.bin`
      - `crash.log`
    - `04`
      - `poc.bin`
      - `crash.log`
    - `05`
      - `poc.bin`
      - `crash.log`

`poc.bin` is the file generated by AFL++ or libFuzzer which triggers the specific bug you found and fixed. Those are available in
`afl_out/default/crashes` or in the seeds dir you provided to libFuzzer. Copy the PoC from the fuzzer's directory into your submission
archive and rename it to poc.bin for each bug.

Please make sure that:

1. All the bugs you report are in the YOLO PNG library, not in your fuzzing stubs
2. Your code compiles properly on Ubuntu 22.04
3. You have actually zipped all of the required files
4. That you don't have previous versions of your files in the archive
5. You haven't included other students' work by mistake